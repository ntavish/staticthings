<!DOCTYPE html>
<head>
<meta charset="utf-8">
  <meta name="author" content="Tavish Naruka" />
  <title>Electronics workflow</title>
<style>
  html { background-color: black; }
  body { background-color: white; }
  /* A section is a slide. It's size is 800x600, and this will never change */
  section {
      font-family: Arial, serif;
      font-size: 20pt;
    }
  address, blockquote, dl, fieldset, form, h1, h2, h3, h4, h5, h6, hr, ol, p, pre, table, ul, dl { padding: 10px 20px 10px 20px; }
  h1, h2, h3 {
    text-align: center;
    margin: 10pt 10pt 20pt 10pt;
  }
  ul, ol {
    margin: 10px 10px 10px 50px;
  }
  section.titleslide h1 { margin-top: 200px; }
  h1.title { margin-top: 150px; }
  h1 { font-size: 180%; }
  h2 { font-size: 120%; }
  h3 { font-size: 100%; }
  blockquote { font-style: italic }
  q {
    display: inline-block;
    width: 700px;
    height: 600px;
    background-color: black;
    color: white;
    font-size: 60px;
    padding: 50px;
  }
  footer {
    position: absolute;
    bottom: 10px;
    right: 20px;
  }

  /* Transition effect */
  /* Feel free to change the transition effect for original
     animations. See here:
     https://developer.mozilla.org/en/CSS/CSS_transitions
     How to use CSS3 Transitions: */
  section {
      -moz-transition: left 400ms linear 0s;
      -webkit-transition: left 400ms linear 0s;
      -ms-transition: left 400ms linear 0s;
      transition: left 400ms linear 0s;
  }

  /* Before */
  section { left: -150%; }
  /* Now */
  section[aria-selected] { left: 0; }
  /* After */
  section[aria-selected] ~ section { left: +150%; }

  /* Incremental elements */

  /* By default, visible */
  .incremental > * { opacity: 1; }

  /* The current item */
  .incremental > *[aria-selected] { color: red; opacity: 1; }

  /* The items to-be-selected */
  .incremental > *[aria-selected] ~ * { opacity: 0.2; }
</style>
</head>
<body>
<section>
  <h1 class="title">Electronics workflow</h1>
  <h2 class="author">Tavish Naruka</h2>
  <h3 class="date"></h3>
</section>
<section class="slide level1" id="prototyping">
<h1 id="prototyping">Prototyping</h1>
<p>General workflow for most hardware projects starts with a prototype.</p>
<figure>
<img src="img/bread.jpg" alt="Prototyping on a bread board"><figcaption>Prototyping on a bread board</figcaption>
</figure>
</section>
<section class="slide level1" id="section">
<h1 id="section"></h1>
<h2 id="overview-of-how-things-are-usually-done">Overview of how things are usually done</h2>
<ul>
<li><p>Sometimes can choose to use a development board, sometimes they are not what is needed, or expensive or not available</p></li>
<li><p>Component selection</p>
<ul>
<li><p>based on constraints like price, availability with vendors, supporting components, size, power requirement, heat, input voltage etc.</p></li>
<li><p>familiarity, ease of use, support, toolchains or other supporting software</p></li>
<li><p>availability of documentation/schematics from manufacturer or other people</p></li>
</ul></li>
</ul>
</section>
<section class="slide level1" id="section-1">
<h1 id="section-1"></h1>
<ul>
<li><p>Prototype on breadboard or prfboard or stripboard (not always possible)</p>
<ul>
<li><p>Not all components are available as DIP, sometimes there are too many lines</p></li>
<li><p>Breadboards/connecting wires dont have good electromagnetic characteristics, sometimes cannot use with high speed parts</p></li>
<li><figure>
<img src="img/perfboard_resize.jpg" alt="perfboard"><figcaption>perfboard</figcaption>
</figure></li>
</ul></li>
</ul>
</section>
<section class="slide level1" id="section-2">
<h1 id="section-2"></h1>
<ul>
<li><p>PCB prototype</p>
<ul>
<li><p>Printed cicuit board is conducting metal laminated over a non-conducting substrate</p></li>
<li><p>First step for making this is a correct schematic</p></li>
<li><figure>
<img src="img/schematic_resize.png"><figcaption></figcaption>
</figure></li>
</ul></li>
</ul>
</section>
<section class="slide level1" id="section-3">
<h1 id="section-3"></h1>
<p>After schematic comes layout</p>
<ul>
<li><p>PCBs can be single layer, dual, multiple layers.</p></li>
<li><p>Single can sometimes be made at home</p></li>
<li><p>PCBs serve a few puposes, like providing conducting paths, heat sink, mechanical support</p></li>
<li><figure>
<img src="img/unrouted_resize.png" alt="unrouted but placed components"><figcaption>unrouted but placed components</figcaption>
</figure></li>
</ul>
</section>
<section class="slide level1" id="section-4">
<h1 id="section-4"></h1>
<p>Now routed</p>
<ul>
<li><figure>
<img src="img/routed.png" alt="routed"><figcaption>routed</figcaption>
</figure></li>
<li><p>Green gots here connect the two layers on this pcb, they are called vias</p></li>
</ul>
</section>
<section class="slide level1" id="section-5">
<h1 id="section-5"></h1>
<ul>
<li><p>Placement is important, like crystals close to uC, decoupling capacitors too</p></li>
<li><p>Mounting holes, connector placement</p></li>
<li><p>Path lengths and presense of other tracks nearby change resistance of tracks, also capacitance and inductance</p></li>
<li><p>differential signals and high speed parallel signals like USB or connections from RAM need length and impedance matching</p></li>
<li><p>RF design</p></li>
</ul>
</section>
<section class="slide level1" id="section-6">
<h1 id="section-6"></h1>
<p>A shielded PCB with an antenna on it</p>
<ul>
<li><figure>
<img src="img/pcbantenna.jpg"><figcaption></figcaption>
</figure></li>
<li><figure>
<img src="img/smdsizes.jpg" alt="smd sizes"><figcaption>smd sizes</figcaption>
</figure></li>
</ul>
</section>
<section class="slide level1" id="section-7">
<h1 id="section-7"></h1>
<p>Firmware</p>
<ul>
<li><p>If using a microcontroller, these days almost exclusively C, and assembly. Sometimes C++</p></li>
<li><p>Some peripherals and stacks can me complex, so compilers and chip maker often provides driver libraries and example code for things like USB, ethernet, or even any other peripherals and external components</p></li>
<li><p>The reference manual is usually a reference for a family of similar chips, and the datasheet is the ultimate refernce</p></li>
</ul>
</section>
<section class="slide level1" id="section-8">
<h1 id="section-8"></h1>
<ul>
<li><p>Things you need to read in the manuals</p>
<ul>
<li><p>memory layout</p></li>
<li><p>how does the chip boot code</p></li>
<li><p>how do interrupts work in this particular chip</p></li>
<li><p>system clocks</p></li>
<li><p>about any peripherals you want to use</p></li>
</ul></li>
</ul>
</section>
<section class="slide level1" id="section-9">
<h1 id="section-9"></h1>
<p>The code that generated for executing for a desktop is called hosted; the host operating system prrovides the code a 'runtime environment'</p>
<p>The code that is run on a microcontroller is called freestanding. The compiler, or you have to provide the C runtime.</p>
<p>By C runtime I mean the startup code, which loads and initialzes different sections of the code. Like global variables, which are not initialized are set to 0, initialized variables in code need to be initialized, etc.</p>
<p>The entry point of your code is usually called 'Reset vector', and that would be the start of your startup code, which would jump to your code afterwards, to a function usually named main().</p>
</section>
<section class="slide level1" id="section-10">
<h1 id="section-10"></h1>
<p>More control over the memory layout is needed when delaing with microcontrollers.</p>
<p>For this, we need to use linker scripts, which are used by the linker portion of toolchain to arrange code. (initialized memory, unitialized memory, stack, function code, or even blocks of assembly).</p>
<p>This kind of control is also needed for bootloades for microcontrollers. For exxample, the code being flashed by the bootloder should not have anything to with the portion of flash where the bootloader resides. So the person making an application uses a linker script where the portion of flash used by bootloader is not mapped.</p>
</section>
<section class="slide level1" id="section-11">
<h1 id="section-11"></h1>
<p>Or the platform chosen can run Linux. But</p>
<ul>
<li><p>It is much easier to do some kinds of things on a microcontroller. Especially things which are time critial or which require realtime behavior.</p></li>
<li><p>Real time behavior is when the system needs to do something within a time limit. Sometimes things dont work if there is a latency or jitter between an event happening and the system doing something</p></li>
<li><p>Things like USB devices are meant to be realized with dedicated systems not general purpose computers.</p></li>
<li><p>Easier tweaking of low level things, could be cheaper, could be easier if system is simple</p></li>
</ul>
</section>
<section class="slide level1" id="section-12">
<h1 id="section-12"></h1>
<p>On the other hand</p>
<ul>
<li><p>It is much much easier to develop your application on a system running linux.</p></li>
<li><p>Lots of things have already been done, so you dont have to reinvent the wheel.</p></li>
<li><p>debugging is easier</p></li>
<li><p>A choice of many languages, C, lua, python, shell, even javascript etc.</p></li>
<li><p>Filesystems, networking, graphics etc. These things may also be done on a some microcontroller, but with a lot more effort.</p></li>
</ul>
</section>
<!-- {{{{ dzslides core
#
#
#     __  __  __       .  __   ___  __
#    |  \  / /__` |    | |  \ |__  /__`
#    |__/ /_ .__/ |___ | |__/ |___ .__/ core :â‚¬
#
#
# The following block of code is not supposed to be edited.
# But if you want to change the behavior of these slides,
# feel free to hack it!
#
-->

<!-- Default Style -->
<style>
  * { margin: 0; padding: 0; }
  details { display: none; }
  body {
    width: 800px; height: 600px;
    margin-left: -400px; margin-top: -300px;
    position: absolute; top: 50%; left: 50%;
    overflow: hidden;
  }
  section {
    position: absolute;
    pointer-events: none;
    width: 100%; height: 100%;
  }
  section[aria-selected] { pointer-events: auto; }
  html { overflow: hidden; }
  body { display: none; }
  body.loaded { display: block; }
  .incremental {visibility: hidden; }
  .incremental[active] {visibility: visible; }
</style>

<script>
  var Dz = {
    remoteWindows: [],
    idx: -1,
    step: 0,
    slides: null,
    params: {
      autoplay: "1"
    }
  };

  Dz.init = function() {
    document.body.className = "loaded";
    this.slides = $$("body > section");
    this.setupParams();
    this.onhashchange();
    this.setupTouchEvents();
    this.onresize();
  }
  
  Dz.setupParams = function() {
    var p = window.location.search.substr(1).split('&');
    p.forEach(function(e, i, a) {
      var keyVal = e.split('=');
      Dz.params[keyVal[0]] = decodeURIComponent(keyVal[1]);
    });
  }

  Dz.onkeydown = function(aEvent) {
    // Don't intercept keyboard shortcuts
    if (aEvent.altKey
      || aEvent.ctrlKey
      || aEvent.metaKey
      || aEvent.shiftKey) {
      return;
    }
    if ( aEvent.keyCode == 37 // left arrow
      || aEvent.keyCode == 38 // up arrow
      || aEvent.keyCode == 33 // page up
    ) {
      aEvent.preventDefault();
      this.back();
    }
    if ( aEvent.keyCode == 39 // right arrow
      || aEvent.keyCode == 40 // down arrow
      || aEvent.keyCode == 34 // page down
    ) {
      aEvent.preventDefault();
      this.forward();
    }
    if (aEvent.keyCode == 35) { // end
      aEvent.preventDefault();
      this.goEnd();
    }
    if (aEvent.keyCode == 36) { // home
      aEvent.preventDefault();
      this.goStart();
    }
    if (aEvent.keyCode == 32) { // space
      aEvent.preventDefault();
      this.toggleContent();
    }
  }

  /* Touch Events */

  Dz.setupTouchEvents = function() {
    var orgX, newX;
    var tracking = false;

    var db = document.body;
    db.addEventListener("touchstart", start.bind(this), false);
    db.addEventListener("touchmove", move.bind(this), false);

    function start(aEvent) {
      aEvent.preventDefault();
      tracking = true;
      orgX = aEvent.changedTouches[0].pageX;
    }

    function move(aEvent) {
      if (!tracking) return;
      newX = aEvent.changedTouches[0].pageX;
      if (orgX - newX > 100) {
        tracking = false;
        this.forward();
      } else {
        if (orgX - newX < -100) {
          tracking = false;
          this.back();
        }
      }
    }
  }

  /* Adapt the size of the slides to the window */

  Dz.onresize = function() {
    var db = document.body;
    var sx = db.clientWidth / window.innerWidth;
    var sy = db.clientHeight / window.innerHeight;
    var transform = "scale(" + (1/Math.max(sx, sy)) + ")";

    db.style.MozTransform = transform;
    db.style.WebkitTransform = transform;
    db.style.OTransform = transform;
    db.style.msTransform = transform;
    db.style.transform = transform;
  }


  Dz.getDetails = function(aIdx) {
    var s = $("section:nth-of-type(" + aIdx + ")");
    var d = s.$("details");
    return d ? d.innerHTML : "";
  }

  Dz.onmessage = function(aEvent) {
    var argv = aEvent.data.split(" "), argc = argv.length;
    argv.forEach(function(e, i, a) { a[i] = decodeURIComponent(e) });
    var win = aEvent.source;
    if (argv[0] === "REGISTER" && argc === 1) {
      this.remoteWindows.push(win);
      this.postMsg(win, "REGISTERED", document.title, this.slides.length);
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
      return;
    }
    if (argv[0] === "BACK" && argc === 1)
      this.back();
    if (argv[0] === "FORWARD" && argc === 1)
      this.forward();
    if (argv[0] === "START" && argc === 1)
      this.goStart();
    if (argv[0] === "END" && argc === 1)
      this.goEnd();
    if (argv[0] === "TOGGLE_CONTENT" && argc === 1)
      this.toggleContent();
    if (argv[0] === "SET_CURSOR" && argc === 2)
      window.location.hash = "#" + argv[1];
    if (argv[0] === "GET_CURSOR" && argc === 1)
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
    if (argv[0] === "GET_NOTES" && argc === 1)
      this.postMsg(win, "NOTES", this.getDetails(this.idx));
  }

  Dz.toggleContent = function() {
    // If a Video is present in this new slide, play it.
    // If a Video is present in the previous slide, stop it.
    var s = $("section[aria-selected]");
    if (s) {
      var video = s.$("video");
      if (video) {
        if (video.ended || video.paused) {
          video.play();
        } else {
          video.pause();
        }
      }
    }
  }

  Dz.setCursor = function(aIdx, aStep) {
    // If the user change the slide number in the URL bar, jump
    // to this slide.
    aStep = (aStep != 0 && typeof aStep !== "undefined") ? "." + aStep : ".0";
    window.location.hash = "#" + aIdx + aStep;
  }

  Dz.onhashchange = function() {
    var cursor = window.location.hash.split("#"),
        newidx = 1,
        newstep = 0;
    if (cursor.length == 2) {
      newidx = ~~cursor[1].split(".")[0];
      newstep = ~~cursor[1].split(".")[1];
      if (newstep > Dz.slides[newidx - 1].$$('.incremental > *').length) {
        newstep = 0;
        newidx++;
      }
    }
    if (newidx != this.idx) {
      this.setSlide(newidx);
    }
    if (newstep != this.step) {
      this.setIncremental(newstep);
    }
    for (var i = 0; i < this.remoteWindows.length; i++) {
      this.postMsg(this.remoteWindows[i], "CURSOR", this.idx + "." + this.step);
    }
  }

  Dz.back = function() {
    if (this.idx == 1 && this.step == 0) {
      return;
    }
    if (this.step == 0) {
      this.setCursor(this.idx - 1,
                     this.slides[this.idx - 2].$$('.incremental > *').length);
    } else {
      this.setCursor(this.idx, this.step - 1);
    }
  }

  Dz.forward = function() {
    if (this.idx >= this.slides.length &&
        this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
        return;
    }
    if (this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
      this.setCursor(this.idx + 1, 0);
    } else {
      this.setCursor(this.idx, this.step + 1);
    }
  }

  Dz.goStart = function() {
    this.setCursor(1, 0);
  }

  Dz.goEnd = function() {
    var lastIdx = this.slides.length;
    var lastStep = this.slides[lastIdx - 1].$$('.incremental > *').length;
    this.setCursor(lastIdx, lastStep);
  }

  Dz.setSlide = function(aIdx) {
    this.idx = aIdx;
    var old = $("section[aria-selected]");
    var next = $("section:nth-of-type("+ this.idx +")");
    if (old) {
      old.removeAttribute("aria-selected");
      var video = old.$("video");
      if (video) {
        video.pause();
      }
    }
    if (next) {
      next.setAttribute("aria-selected", "true");
      var video = next.$("video");
      if (video && !!+this.params.autoplay) {
        video.play();
      }
    } else {
      // That should not happen
      this.idx = -1;
      // console.warn("Slide doesn't exist.");
    }
  }

  Dz.setIncremental = function(aStep) {
    this.step = aStep;
    var old = this.slides[this.idx - 1].$('.incremental > *[aria-selected]');
    if (old) {
      old.removeAttribute('aria-selected');
    }
    var incrementals = this.slides[this.idx - 1].$$('.incremental');
    if (this.step <= 0) {
      incrementals.forEach(function(aNode) {
        aNode.removeAttribute('active');
      });
      return;
    }
    var next = this.slides[this.idx - 1].$$('.incremental > *')[this.step - 1];
    if (next) {
      next.setAttribute('aria-selected', true);
      next.parentNode.setAttribute('active', true);
      var found = false;
      incrementals.forEach(function(aNode) {
        if (aNode != next.parentNode)
          if (found)
            aNode.removeAttribute('active');
          else
            aNode.setAttribute('active', true);
        else
          found = true;
      });
    } else {
      setCursor(this.idx, 0);
    }
    return next;
  }
  
  Dz.postMsg = function(aWin, aMsg) { // [arg0, [arg1...]]
    aMsg = [aMsg];
    for (var i = 2; i < arguments.length; i++)
      aMsg.push(encodeURIComponent(arguments[i]));
    aWin.postMessage(aMsg.join(" "), "*");
  }

  window.onload = Dz.init.bind(Dz);
  window.onkeydown = Dz.onkeydown.bind(Dz);
  window.onresize = Dz.onresize.bind(Dz);
  window.onhashchange = Dz.onhashchange.bind(Dz);
  window.onmessage = Dz.onmessage.bind(Dz);
</script>


<script> // Helpers
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {

      // closest thing possible to the ECMAScript 5 internal IsCallable
      // function 
      if (typeof this !== "function")
      throw new TypeError(
        "Function.prototype.bind - what is trying to be fBound is not callable"
      );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
            return fToBind.apply( this instanceof fNOP ? this : oThis || window,
                   aArgs.concat(Array.prototype.slice.call(arguments)));
          };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
  }

  var $ = (HTMLElement.prototype.$ = function(aQuery) {
    return this.querySelector(aQuery);
  }).bind(document);

  var $$ = (HTMLElement.prototype.$$ = function(aQuery) {
    return this.querySelectorAll(aQuery);
  }).bind(document);

  NodeList.prototype.forEach = function(fun) {
    if (typeof fun !== "function") throw new TypeError();
    for (var i = 0; i < this.length; i++) {
      fun.call(this, this[i]);
    }
  }

</script>
<!-- vim: set fdm=marker: }}} -->
</body>
</html>
